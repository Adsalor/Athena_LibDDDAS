#-------------------------------------------------------------------------
#-- Theories about Events -- an event is something which can be assigned a 
#   probability measure

load "CharFun.ath"
load "Prob.ath"
load "Random.ath"
load "RealExt.ath"

module Evnt { 


	#-------------------------  RELEVANT DOMAINS -------------------------  


	#-- Domain of all the relationships which can be used to define Event 
	#  Eg. -  We are concerned with relationships like >, <=, etc for 
	#  statistical analysis of random variables

	domain Rel 

	#-- Domain of all events - An event is a set of outcomes which may or may 
	#   not come true. For any relation like <, >=, the associated event can
	#   be that the relation has come true
	#   The consE constructor creates an event with a relationship, rv, and Real 
	#   NOTE: Would have preferred to create a polymorphic datatype, but 
	#   having issue with the Athena syntax

	datatype Event  :=  (consE rel:Rel rv:Random.RandVar rl:Real) # wrt to a single rv
					  | (consErvs rel:Rel rvS:Random.RandVarSet rl:Real) # wrt all in a set of rvs

	#-- sets of events

	datatype EventSet := emptyES | (consES EventSet Event)


	#------------------------  RELEVANT FUNCTIONS ------------------------  

	#-- Two events are complementary

	declare complement : [Event Event] -> Boolean	

	#-- Disjoint events

	declare disjoint : [Event Event] -> Boolean		

	#-- get complementary event

	declare get-comp : [Event] -> Event	

	#-- Given an event  [X1 Rel y, X2 Rel y, ...]  
	#   it returns a set of Probabilities [P(X1 Rel y), P(X2 Rel y), ... ]

	declare get-set-probs : [Event] -> RealExt.RealSet		

	#-- membership opertaor for EventSet

	declare inES: [EventSet Event] -> Boolean 	

	#-- Probability of an event

	declare probE : [Event] -> Real	


	#------------------------  RELEVANT VARIABLES ------------------------  

	#-- The relationship symbols which we will use to define events 
	#   interesting to us 
	declare > , <= , == : Rel

	#-- 

	define [symbl] := [?symbl:Rel] 

	define [E1 E2] := [?E1:Event ?E2:Event]

	define [x] := [?x:Random.RandVar]

	define [R] := [?R:Real]

	define [rvSet] := [?rvSet:Random.RandVarSet]

	#-------------------------  RELEVANT THEORY  -------------------------

	# Complementary relationship between the > and <= relations

	assert comp-<=-&-> :=
	(forall x R .
		(
			(complement (consE <= x R) (consE > x R))
		)
	)

	#-- comp-2-way states that complement is a two-way relation

	assert comp-2-way :=
	(forall E1 E2 .
		(complement E1 E2) <==> (complement E2 E1)
	)

	# get-set-probs length axiom - number of probabilities is equal to number of rvs
	assert get-set-probs-axiom :=
	(forall rvSet symbl R .
		(
			(RealExt.lenRS (get-set-probs (consErvs symbl rvSet R)))
			= (Random.lenRVS rvSet)
		)
	)


	#-- get-comp definition

	assert get-comp-axiom :=
	(forall E1 .
		    (complement E1 (get-comp E1))
	)

	#-- complement-rule - Complement Rule states that the sum of the  
	#   probabilities of an event and its complement must equal 1

	assert complement-rule :=
	(forall E1 E2 .
		(
			(complement E1 E2) 
				<==>
				( 
					  ((probE E2) = (1.0 - (probE E1)))
				    & ((probE E1) = (1.0 - (probE E2))) 
				)
		)
	)


	#-- cdf-prob-axiom states that cdf(X,x) = P(X <= x)

	assert cdf-prob-axiom :=
	(forall x R .
		(
			(Random.cdf x R) = (probE (consE <= x R))
		)
	)



#	#-- evnt-RVS-axiom states that defining an event over an entire set of rvS
#	#   is equal to defining the same event for each rv in the set

#	assert evnt-RVS-axiom :=
#	(forall rvSet R ?symbl:Rel .
#		(
#			(consErvs ?symbl:Rel rvSet R)
#			=
#			 (forall x .
#			 	((Random.inRVS rvSet x)
#			 		==>
#			 			(consE ?symbl:Rel x R)) 
#			 )
#		)
#	)


	#-- p-Min-axiom states that P(min[X1,X2...] > y) = P( [X1 > y, X2 > y, ...])

	assert p-Min-axiom :=
	(forall rvSet R .
		(
			(probE (consE > (Random.minRVS rvSet) R))
			=
			(probE (consErvs > rvSet R))
		)
	)


	#-- rvs-Ind-axiom states that 
	#   P( [X1 Rel y, X2 Rel y, ...]) = Product([P(Xi Rel y)])
	#  for a set of Independent rvs

	assert rvs-Ind-axiom :=
	(forall rvSet R symbl .
		(
			(Random.rvSetInd rvSet)
				==>
					(
						(probE (consErvs symbl rvSet R))
						=
						(RealExt.prod (get-set-probs (consErvs symbl rvSet R)))
					)
		)
	)	


	#-- rvs-Id-axiom states that 
	#  (get-set-probs (consErvs symbl rvSet R)) is a homogenous set
	#  if all rvs in a set of rvs are identically distributed

	assert rvs-Id-axiom :=
	(forall rvSet R symbl .
		(
			(Random.rvSetId rvSet)
				==>
					(
						  (RealExt.homoRS (get-set-probs (consErvs symbl rvSet R)))
						& ((RealExt.elmntHRS (get-set-probs (consErvs symbl rvSet R))) 
							= 
								(probE (consE symbl (Random.rvSetIdElmnt rvSet) R)))	
					)
		)
	)


# ***PROVE THEOREM ((Random.cdf x R) = (1.0 - (probE (consE > x R))))
# and ((probE (consE > x R)) = 1.0 - (Random.cdf x R))


	#-- THEOREM-probability-Comp-Evnts states that 
	#   P(E1) = 1 - P(comp(E1))

	define THEOREM-probability-Comp-Evnts :=
	(forall E1 .  
		(
			(probE E1) 
				= 
					(1.0 - (probE (get-comp E1)))
		)
	)

	conclude THEOREM-probability-Comp-Evnts
	pick-any E1
	let{
		e2 := (get-comp E1);
		is-comp-E1-e2 := (!uspec get-comp-axiom E1); #(complement E1 (get-comp E1))
		two-way-comp-e2-E1 := (!uspec (!uspec comp-2-way E1) e2); #(complement E1 (get-comp E1)) <==> (complement (get-comp E1) E2)
		is-comp-e2-E1 := (!mp (!left-iff two-way-comp-e2-E1) is-comp-E1-e2); #(complement (get-comp E1) E2)
		comp-rul-E1-e2 := (!uspec (!uspec complement-rule E1) e2);
		p-options-comp := (!mp (!left-iff comp-rul-E1-e2) is-comp-E1-e2)
	}
	(!right-and p-options-comp)


	#-- THEOREM-probability-MIN-<=-&-> states that 
	#   P(min[X1,X2,...] <= y) = 1 - P(min[X1,X2,...] > y)

	define THEOREM-probability-MIN-<=-&-> :=
	(forall rvSet R .  
		(
			(probE (consE <= (Random.minRVS rvSet) R)) 
				= 
					(1.0 - (probE (consE > (Random.minRVS rvSet) R)))
		)
	)

	conclude THEOREM-probability-MIN-<=-&-> 
	pick-any rvSet
	pick-any R 
	let{
		min := (Random.minRVS rvSet);
		e1 :=  (consE <= min R);
		e2 :=  (consE > min R);
		is-complement := (!uspec (!uspec comp-<=-&-> min) R);
		comp-rul := (!left-iff (!uspec (!uspec complement-rule e1) e2))
	}
	(!right-and (!mp comp-rul is-complement))


	#-- THEOREM-probability-MIN-<=-&-> states that 
	#   P(min[X1,X2,...] <= y) = 1 - P(Xi > y)^N

	define THEOREM-probability-MIN-<=-IID-RVS :=
	(forall rvSet R . 
		(Random.iIdRvs rvSet)
		==> 
		(
			(probE (consE <= (Random.minRVS rvSet) R)) 
				= 
					(1.0 - (RealExt.pow (probE (consE > (Random.rvSetIdElmnt rvSet) R)) (Random.lenRVS rvSet) ) )
		)
	)

	conclude THEOREM-probability-MIN-<=-IID-RVS 
	pick-any rvSet
	pick-any R 
	assume (Random.iIdRvs rvSet)
	let{
		rvSetIid := (Random.iIdRvs rvSet);
		rvSetId := (!left-and (!mp (!left-iff (!uspec Random.iIDRvs-axiom rvSet)) rvSetIid));
		rvSetInd := (!right-and (!mp (!left-iff (!uspec Random.iIDRvs-axiom rvSet)) rvSetIid));
		cnnct-to-> := (!uspec (!uspec THEOREM-probability-MIN-<=-&-> rvSet) R);
		cnnct-to-set := (!chain [ (probE (consE <= (Random.minRVS rvSet) R))
								= (1.0 - (probE (consE > (Random.minRVS rvSet) R))) [cnnct-to->]
								= (1.0 - (probE (consErvs > rvSet R))) [p-Min-axiom]	
								]);
		cnnct-to-rvs-ind := (!mp (!uspec (!uspec (!uspec rvs-Ind-axiom rvSet) R) >) rvSetInd);
		cnnct-to-rvs-id := (!mp (!uspec (!uspec (!uspec rvs-Id-axiom rvSet) R) >) rvSetId);
		cnnct-to-elmntHRS=probE := (!right-and cnnct-to-rvs-id);
		cnnct-to-get-set-homo := (!left-and cnnct-to-rvs-id);
		cnnct-to-prod-pow-axm := (!mp (!uspec RealExt.prod-pow-axiom (get-set-probs (consErvs > rvSet R))) cnnct-to-get-set-homo);
		cnnct-to-get-set-probs-len := (!uspec (!uspec (!uspec get-set-probs-axiom rvSet) >) R)
	}
	(!chain [  (probE (consE <= (Random.minRVS rvSet) R))
			 = (1.0 - (probE (consErvs > rvSet R))) [cnnct-to-set]
			 = (1.0 - (RealExt.prod (get-set-probs (consErvs > rvSet R)))) [cnnct-to-rvs-ind]
			 = (1.0 - (RealExt.pow (RealExt.elmntHRS (get-set-probs (consErvs > rvSet R))) (RealExt.lenRS (get-set-probs (consErvs > rvSet R))))) [cnnct-to-prod-pow-axm]
			 = (1.0 - (RealExt.pow (probE (consE > (Random.rvSetIdElmnt rvSet) R)) (RealExt.lenRS (get-set-probs (consErvs > rvSet R))))) [cnnct-to-elmntHRS=probE]
			 = (1.0 - (RealExt.pow (probE (consE > (Random.rvSetIdElmnt rvSet) R)) (Random.lenRVS rvSet))) [cnnct-to-get-set-probs-len]
		])	 

}# end module
