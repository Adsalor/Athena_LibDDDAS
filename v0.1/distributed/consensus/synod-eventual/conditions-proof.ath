#-------------------------------------------------------------------------
# Testing predicate fairness proof 

load "lib/main/nat-less"
load "Athena_LibDDDAS/distributed/consensus/synod-eventual/symbols.ath"
load "Athena_LibDDDAS/distributed/consensus/synod-eventual/system.ath"
load "Athena_LibDDDAS/distributed/consensus/synod-eventual/behavior.ath"
load "Athena_LibDDDAS/distributed/consensus/synod-eventual/conditions.ath"
load "Athena_LibDDDAS/distributed/consensus/synod-eventual/methods.ath"



extend-module Synod { 

	#-- Domain of all predicate over configurations

	domain Predicate  

	declare CNDPred : Predicate # a Synod specific predicate  

	#-- Function to check if a predicate is true at a configuration

	declare isTrue : [Predicate Configuration] -> Boolean

	# datatype sequence (defined by a finite set of steps)

	datatype Sequence :=   nilSeq
						| (consSeq Sequence Step)

	# the sequence which causes all higher numbered proposals to fail permanently

	declare CNDSeq : Sequence

	# function to signify that the sequence has happened

	declare happensSeq : [Configuration Sequence] -> Boolean

	# function to go from config --> config via a sequence

	declare postSeq : [Configuration Sequence] -> Configuration

	# function to check if predicate is enabled at a configuration

	declare enabled : [Configuration Predicate] -> Boolean	

	define [cfg1 cfg2 prd sq] := [?cfg1:Configuration ?cfg2:Configuration ?prd:Predicate ?sq:Sequence]

	#-- Enabled definition
	#-- True if \E Seq and config2 such that if Config1 Seq-> Config2 happens isTrue Predicate config2

	define Enabled-Def :=
	(forall T i prd .
		(
			(enabled (config (rho T i)) prd) 
				<==> 
					(exists sq . 
								((happensSeq (config (rho T i)) sq) ==> (exists j . (((postSeq (config (rho T i)) sq) = (config (rho T j))) & (isTrue prd (config (rho T j))))))
					)
		)
	)  


	#-- Predicate fairness

	define F-Predicate-Axm :=
	(forall T i prd .
		( (enabled (config (rho T i)) prd) 
				==> 
					(
	            		  (exists j . (i N.<= j) 
	            		   			& (isTrue prd (config (rho T j))) )
	            	    | (exists k . (i N.< k)
	            	    			& (forall j .
	            	    			   (k N.<= j)
	            	    			     ==>
	            	    			     	(~(enabled (config (rho T j)) prd))
	            	    			  )

	            	       )		
					)
		)
	)


	#-- CNDPred definition with respect to CND
	#-- True iff \E nonfaulty proposer ready to propose a non-interrupting proposal to a nonfaulty quorum 

	define Synod-Pred :=
	(forall T i .
		(
			(isTrue CNDPred (config (rho T i))) 
				<==> 
					(exists p b Q .
							  (prp p) # p is a proposer
							& (nonfaulty p) # p is non-faulty					  
							& (P1+P2-True b) # the proposal number b satisfies the non-interruption condition
							& (   (all-inQ-NF Q) # all acceptors in Q are non-faulty
								& (rdy2snd-1a-all-inQ p Q (rho T i) b)) # p is ready to send a 1a msg with number b to all acceptors in Q
					)
		)
	)


	#-- A function that extracts the highest proposal number yet proposed until a configuration

	declare highest : [Configuration] -> Ballot

	#-- Enabled IOE. Needs to be defined in terms of CNDPred. Need to conect CNDPred to CND and CND to proposer ready to propose highest

	#-- If a proposer becomes ready to propoe the highest, then 
	#-- either the predicate is true at j >= i 
	# -- OR some proposer always becomes ready to propose the highest

	define Prop-Retry :=
	(forall T i .
	   (exists p .
				( 
					  (prp p) 
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
					  )					
				)
		)
			==>		
				(
				   (exists j . (i N.<= j) 
			   			& (isTrue CNDPred (config (rho T j))) ) 		    # 
			    |  (forall k .  (i N.< k) 
			    				==>
			    				(exists j .
		    	    				    (k N.<= j) 
									&	(exists p .
												( 
													  (prp p) 
													& (nonfaulty p) 
													& (forall a . (inQ a Q) 
														                ==> 
														                      (nonfaulty a) 
														                    & (ready-to (rho T j) p (send p (consM p a 1a (highest (config (rho T j))) nilV)))
													  )					
												)
										)
		    	    			)
			    	) 	
			    )
            
	)


	#-- CNDSeq is the special witness sequence that satisfies the enabling condition 
	#   every time a proposer becomes ready to propose the highest number yet

	define Wit-Seq :=
	(forall T i . 
		(
			(exists p .
					( 
						  (prp p) 
						& (nonfaulty p) 
						& (forall a . (inQ a Q) 
							                ==> 
							                      (nonfaulty a) 
							                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
						  )					
					)
			)
				==>
					((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
		)
	) 

	
	#-- In all paths, eventually some proposer becomes ready to propose the highest proposal number
	define Some-Prp-Ready :=
	(forall T .
			   (exists i p .
						( 
							  (prp p) 
							& (nonfaulty p) 
							& (forall a . (inQ a Q) 
								                ==> 
								                      (nonfaulty a) 
								                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
							  )					
						)
				)	
	)


#---------------------------------------------------------------------------------------------------------------------------
# The assertions
	assert Enabled-Def 
	assert F-Predicate-Axm 
	assert Prop-Retry 
	assert Wit-Seq
	assert Some-Prp-Ready
	assert Synod-Pred


#---------------------------------------------------------------------------------------------------------------------------
# The proofs 

	define CNDSeq-CNDPred-rel :=
	(forall T i . 
		(
			((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
				==>
					(enabled (config (rho T i)) CNDPred)	
		)
	)

	define CNDSeq-CNDPred-rel-step1 :=
	(forall T i . 
		(
			((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
				==>
					(exists sq . 
								((happensSeq (config (rho T i)) sq) ==> (exists j . (((postSeq (config (rho T i)) sq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
					)
		)
	)

	(!prove CNDSeq-CNDPred-rel-step1 [Enabled-Def]) 

	(!prove CNDSeq-CNDPred-rel [CNDSeq-CNDPred-rel-step1 Enabled-Def])

#---------------------------------------------------------------------------------------------------------------------------

define CNDPred-enabled-IOE :=
	(forall T i . 
	   ((exists p .
				( 
					  (prp p) 
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
					  )					
				)
		)
	   	& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
	   	& (enabled (config (rho T i)) CNDPred) )
	   		==>
	   		( 
				   (exists j . (i N.<= j) 
			   			& (isTrue CNDPred (config (rho T j))) )		   		 		    
			    |  (forall k .  (i N.< k)
			    				==>
			    				(exists j .
		    	    				    (k N.<= j) 
									&	(enabled (config (rho T j)) CNDPred) 
		    	    			)
			    	)
	    	) 	

            
	)


	define CNDPred-enabled-IOE-step1 :=
	(forall T i .
	   ((exists p .
				( 
					  (prp p) 
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
					  )					
				)
		)
	   	& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j)))))))
			==>		
				(
				   (exists j . (i N.<= j) 
			   			& (isTrue CNDPred (config (rho T j))) ) 		    # 
			    |  (forall k .  (i N.< k) 
			    				==>
			    				(exists j .
		    	    				    (k N.<= j) 
		    	    				    & ((happensSeq (config (rho T j)) CNDSeq) ==> (exists y . (((postSeq (config (rho T j)) CNDSeq) = (config (rho T y))) & (isTrue CNDPred (config (rho T y))))))
		    	    			)
			    	) 	
			    )
            
	)

	(!prove CNDPred-enabled-IOE-step1 [Prop-Retry Wit-Seq])



	define CNDPred-enabled-IOE-step2 :=
	(forall T i .
	   ((exists p .
				( 
					  (prp p) 
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
					  )					
				)
		)
	   	& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j)))))))
			==>		
				(
				   (exists j . (i N.<= j) 
			   			& (isTrue CNDPred (config (rho T j))) ) 		    # 
			    |  (forall k .  (i N.< k) 
			    				==>
			    				(exists j .
		    	    				    (k N.<= j) 
										& (enabled (config (rho T j)) CNDPred)
		    	    			)
			    	) 	
			    )
            
	)

	(!prove CNDPred-enabled-IOE-step2 [CNDPred-enabled-IOE-step1 Enabled-Def])


	define CNDPred-enabled-IOE-step3 :=
	(forall T i .
	   ((exists p .
				( 
					  (prp p) 
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
					  )					
				)
		)
	   	& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
	   	& (enabled (config (rho T i)) CNDPred) )
			==>		
				(
				   (exists j . (i N.<= j) 
			   			& (isTrue CNDPred (config (rho T j))) ) 		    # 
			    |  (forall k .  (i N.< k) 
			    				==>
			    				(exists j .
		    	    				    (k N.<= j) 
										& (enabled (config (rho T j)) CNDPred)
		    	    			)
			    	) 	
			    )
            
	)

	(!prove CNDPred-enabled-IOE-step3 [CNDPred-enabled-IOE-step2 CNDSeq-CNDPred-rel])


	(!prove CNDPred-enabled-IOE [CNDPred-enabled-IOE-step3])	

#---------------------------------------------------------------------------------------------------------------------------
	define F-Predicate-Axm-CNDPred :=
	(forall T i .
		( (enabled (config (rho T i)) CNDPred) 
				==> 
					(
	            		  (exists j . (i N.<= j) 
	            		   			& (isTrue CNDPred (config (rho T j))) )
	            	    | (exists k . (i N.< k)
	            	    			& (forall j .
	            	    			   (k N.<= j)
	            	    			     ==>
	            	    			     	(~(enabled (config (rho T j)) CNDPred))
	            	    			  )

	            	       )		
					)
		)
	)

	(!prove F-Predicate-Axm-CNDPred [F-Predicate-Axm])

#---------------------------------------------------------------------------------------------------------------------------

	define CNDPred-enabled-IOE-implies-true :=
	(forall T i .
	   ((exists p .
				( 
					  (prp p) 
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
					  )					
				)
		)
	   	& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
	   	& (enabled (config (rho T i)) CNDPred) )
			==>		
	   		( 
				   (exists j . (i N.<= j) 
			   			& (isTrue CNDPred (config (rho T j))) )		   		 		    
	    	) 
            
	)


	define CNDPred-enabled-IOE-implies-true-step1 :=
	(forall T i .
	(
	   ((exists p .
				( 
					  (prp p) 
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
					  )					
				)
		)
	   	& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j .  (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
	   	& (enabled (config (rho T i)) CNDPred) )			
				==> 
					(
	            		  (exists j . (i N.<= j) 
	            		   			& (isTrue CNDPred (config (rho T j))) )
	            	    | (exists k . (i N.< k)
	            	    			& (forall j .
	            	    			   (k N.<= j)
	            	    			     ==>
	            	    			     	(~(enabled (config (rho T j)) CNDPred))
	            	    			  )

	            	       )		
					)
		)
	)

	(!prove CNDPred-enabled-IOE-implies-true-step1 [F-Predicate-Axm-CNDPred])

	(!prove CNDPred-enabled-IOE-implies-true [CNDPred-enabled-IOE-implies-true-step1 CNDPred-enabled-IOE])


#---------------------------------------------------------------------------------------------------------------------------

	
	#-- This theorem states that the predicate corresponding 
	#-- to the conditions CND is eventually satisfied
	define CNDPred-Theorem :=
	(forall T . 
	   		( 
				   (exists j . (isTrue CNDPred (config (rho T j))) )		   		 		    
	    	) 	       
	)


	define CNDPred-Theorem-step1 :=
	(forall T i .
		(
		   (exists p .
					( 
						  (prp p) 
						& (nonfaulty p) 
						& (forall a . (inQ a Q) 
							                ==> 
							                      (nonfaulty a) 
							                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
						  )					
					)
			)
				
		==> 
				((happensSeq (config (rho T i)) CNDSeq) ==> (exists j . (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
		)									
	)

	(!prove CNDPred-Theorem-step1 [Wit-Seq])	


	define CNDPred-Theorem-step2 :=
	(forall T .
		(exists i .
		   (exists p .
					( 
						  (prp p) 
						& (nonfaulty p) 
						& (forall a . (inQ a Q) 
							                ==> 
							                      (nonfaulty a) 
							                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
						  )					
					)
			)

			& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j . (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
		)
	)

	(!prove CNDPred-Theorem-step2 [CNDPred-Theorem-step1 Some-Prp-Ready])


	define CNDPred-Theorem-step3 :=
	(forall T .
		(exists i .
		   (exists p .
					( 
						  (prp p) 
						& (nonfaulty p) 
						& (forall a . (inQ a Q) 
							                ==> 
							                      (nonfaulty a) 
							                    & (ready-to (rho T i) p (send p (consM p a 1a (highest (config (rho T i))) nilV)))
						  )					
					)
			)

			& ((happensSeq (config (rho T i)) CNDSeq) ==> (exists j . (((postSeq (config (rho T i)) CNDSeq) = (config (rho T j))) & (isTrue CNDPred (config (rho T j))))))
			& (enabled (config (rho T i)) CNDPred) 
		)
	)

	(!prove CNDPred-Theorem-step3 [CNDPred-Theorem-step2 Some-Prp-Ready CNDSeq-CNDPred-rel])	

	(!prove CNDPred-Theorem [CNDPred-Theorem-step3 CNDPred-enabled-IOE-implies-true])	



	#-- CND will be true
	#-- (this step is just to expand CNDPred into CND)
	define CND-eventually-true :=
	(forall T .
		(exists i p b Q .
					  (prp p) # p is a proposer
					& (nonfaulty p) # p is non-faulty					  
					& (P1+P2-True b) # the proposal number b satisfies the non-interruption condition
					& (   (all-inQ-NF Q) # all acceptors in Q are non-faulty
						& (rdy2snd-1a-all-inQ p Q (rho T i) b)) # p is ready to send a 1a msg with number b to all acceptors in Q
		)
	)	

	(!prove CND-eventually-true [Synod-Pred CNDPred-Theorem])	


}