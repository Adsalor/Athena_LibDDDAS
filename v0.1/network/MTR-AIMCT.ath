#-------------------------------------------------------------------------
# Lines beginning with '#+-' are used to create the hierarchy graph
#+- Multicopy Two-Hop Relay Protocol with Arbitrary Inter-meeting and Constant TTLs
#-- Based on - Al Hanbali, 2007, Simple model for the performance evaluation of a class of two-hop relay protocols

load "Athena_LibDDDAS/network/Netwrk.ath"
load "Athena_LibDDDAS/math/Prob/PrbIndRv.ath"

module MTR-AIMCT { 


	#-------------------------  RELEVANT DOMAINS -------------------------  



	#------------------------  RELEVANT FUNCTIONS ------------------------  

	# MTR property: set of the random variables represnting the intermeeting times of the source and each relay with respect to the source
	# (The set {Xsd, D1, ..., DN-1} in equation 8)

	# declare mtrImtngTms: [Random.RandVarSet] -> Random.RandVarSet	



	#------------------------  RELEVANT VARIABLES ------------------------  

	define [NETWORK] := [?NETWORK:Netwrk.Network]

	define [R] := [?R:Real]

	#-------------------------  RELEVANT THEORY  -------------------------

	#-- Mobility Model constraints : 
	# "All nodes move
	# 	1. independently of each other 
	#	2. according to the same random mobility model"
	#-- Captured by intermeetings times are iid --
	#   The intermeeting time between each pair of nodes
	#   is represented by a random variable and the times 
	#   for all different pairs are iid 

	assert intrMtngTmsIID :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
					  (Random.rvsIID (Netwrk.netNodeIMTmSet NETWORK))
	)


	#-- MTR Protocol Transmission Constraints:

	#-- Source node can transmit a packet to destination or to relay 
	#   nodes

	assert srcTrnsmitRul1 :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
		(forall ?src:Netwrk.MobileNode .
		 	    (Netwrk.nodeIsSrc ?src:Netwrk.MobileNode) 
		 	 		==>
				( 
						(Netwrk.prtSrcCanTrnsmt2Rlys Netwrk.MTR_AIMCT ?src:Netwrk.MobileNode)
					|	(Netwrk.prtSrcCanTrnsmt2Dst Netwrk.MTR_AIMCT ?src:Netwrk.MobileNode)	
				) 
		)
	)	

	#-- Relay node can only transmit a packet to destination

	assert rlyTrnsmitRul1 :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
			(forall ?rly:Netwrk.MobileNode .
			 	    (Netwrk.nodeIsRly ?rly:Netwrk.MobileNode) 			 	 
			 	 	==>
							(Netwrk.prtRlyOnlyTrnsmt2Dst Netwrk.MTR_AIMCT ?rly:Netwrk.MobileNode)
					 
			)		
	)

	#-- source cannot transmit a copy to a relay that already has a copy

	assert srcTrnsmitRul2 :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
		(forall ?src:Netwrk.MobileNode ?rly:Netwrk.MobileNode ?pckt:Netwrk.Packet .
		 	    (   (Netwrk.nodeIsSrc ?src:Netwrk.MobileNode)
		 	      & (Netwrk.nodeIsRly ?rly:Netwrk.MobileNode) 	
		 	    )		
		 	 		==>
				( 
					 ( (Netwrk.nodeHasCpy ?rly:Netwrk.MobileNode ?pckt:Netwrk.Packet)
					 	 ==>
					 	 	(~(Netwrk.nodeCanTrnsmt ?src:Netwrk.MobileNode ?rly:Netwrk.MobileNode))
					 )	
				) 
		)
	)


	#-- All relay nodes have same transmission capabilities

	assert rlysSameTrnsmCap :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
							  (Netwrk.netAllRlySameTrnsCap NETWORK)
	)	
	


	#-- TTLs are constant 

	assert cnstntTTL :=
	(forall NETWORK .
	  (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
		(exists ?constantTTL:Real .
			(forall ?pckt:Netwrk.Packet ?node:Netwrk.MobileNode .
				(
					(Netwrk.inMNS (Netwrk.netNodeSet NETWORK) ?node.Netwrk.MobileNode)
					==>
						(= ?constantTTL:Real (Netwrk.pcktTTL ?pckt:Netwrk.Packet ?node:Netwrk.MobileNode))
				)
			)
		)
	)


	#-- Number of packets = number of source+relay nodes
	#  K = N

	assert numPckts=NumSrc+Rly :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
		 ( (Netwrk.netNumCopies NETWORK) = (Netwrk.numNodes (Netwrk.netNodeSet-Dest NETWORK)))
	)
		


	#-- Axiom: The time Td to deliver packet to destination
	#  is the minimum of the intermeeting time of the source
	#  and the dest and the time needed for the relay nodes to deliver
	#  a copy to the dest

	define Td-MIN-IMTSrc-Dest&TTRelays->Dest :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
	 	(
	 		(Netwrk.netTd NETWORK)
	 		= 
	 			(Random.minRVS 
				 		(Random.consRVS
				 			(Netwrk.netIMTSource-Dest NETWORK) 
				 				(Netwrk.netTTRelays->Dest NETWORK)))
	 	)
	)


	conclude Td-MIN-IMTSrc-Dest&TTRelays->Dest 
	pick-any NETWORK
	assume (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT)
	let{
		assum := (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT);
		conn2-numPckts=NumSrc+Rly := (!mp (!uspec numPckts=NumSrc+Rly NETWORK) assum);  
		conn2-timeToTransmit-axiom := (!mp (!uspec Netwrk.timeToTransmit-axiom NETWORK) conn2-numPckts=NumSrc+Rly)
	}
	(!claim conn2-timeToTransmit-axiom)

  
 	#-- Assumption for equation 9:
 	#  The intermeeting time of source and dest given by Xsd
 	#  and the time taken to deliver by each
 	#  relay node Di,.... are mutually independent 
 	#  and Di forall i are identical

	define IMTSource-Dest-MI-TTRelays->Source :=
	(forall NETWORK .
	 (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
	 	(
	 		(Random.rvSetInd
		 		(Random.consRVS
		 			(Netwrk.netIMTSource-Dest NETWORK) 
		 				(Netwrk.netTTRelays->Dest NETWORK)))
	 		& (Random.rvSetId (Netwrk.netTTRelays->Dest NETWORK))
	 	)
	)


	conclude IMTSource-Dest-MI-TTRelays->Source
	pick-any NETWORK
	assume (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT)
	let{
		assum := (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT);
		imsIID := (!mp (!uspec intrMtngTmsIID NETWORK) assum);
		conn2-iMTimeSrcDst-ind-RlyTms-axiom := (!mp (!uspec Netwrk.iMTimeSrcDst-ind-RlyTms-axiom NETWORK) imsIID);
		homoRelys := (!mp (!uspec rlysSameTrnsmCap NETWORK) assum);
		homoRlys-and-iidIMS:= (!both homoRelys imsIID);
		conn2-identicalTrnsmTimeOfRlys-axiom := (!uspec Netwrk.identicalTrnsmTimeOfRlys-axiom NETWORK);
		rlyTrnsDlysId := (!mp conn2-identicalTrnsmTimeOfRlys-axiom homoRlys-and-iidIMS)
	}
	(!both conn2-iMTimeSrcDst-ind-RlyTms-axiom rlyTrnsDlysId)



	#-- THEOREM-Prob-AIMCT-Td<=R states that the probability 
	#   that the Td for MTR-AIMCT will be <= R is given by
	#   = 1- prod[(1- G(X)), P(Di > y)^N]
	#   i.e, Eq 9 in paper 

	define THEOREM-Prob-AIMCT-Td<=R :=
	(forall NETWORK R .
		(= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT) ==>
		 	(
		 		(Prob.probE (Prob.consE Prob.<= (Netwrk.netTd NETWORK) R))
		 		= (1.0 - 
		 			(* 
		 				(1.0 - (Random.cdf (Netwrk.netIMTSource-Dest NETWORK) R))
		 				(RealExt.pow 
		 					(Prob.probE 
		 						(Prob.consE Prob.> 
		 							(Random.rvSetIdElmnt 
		 								(Netwrk.netTTRelays->Dest NETWORK)) R)) 
		 					(Random.lenRVS (Netwrk.netTTRelays->Dest NETWORK))) ))
		 	)
	)

	conclude THEOREM-Prob-AIMCT-Td<=R
	pick-any NETWORK
	pick-any R
	assume (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT)
	let{
		netIsAIMCT := (= (Netwrk.netPrtInUse NETWORK) Netwrk.MTR_AIMCT);
		Mi-&-Id := (!mp (!uspec IMTSource-Dest-MI-TTRelays->Source NETWORK) netIsAIMCT);
		Td=Min := (!mp (!uspec Td-MIN-IMTSrc-Dest&TTRelays->Dest NETWORK) netIsAIMCT);
		rvSet := (Random.consRVS
		 			(Netwrk.netIMTSource-Dest NETWORK) 
		 				(Netwrk.netTTRelays->Dest NETWORK));
		y :=  (Netwrk.netIMTSource-Dest NETWORK);
		rvSetTail := (Netwrk.netTTRelays->Dest NETWORK); 						
		PrbMin<= := (!uspec (!uspec (!uspec Prob.PrbIndRv.THEOREM-probability-MIN-<=-MInd-TId-RVS y) rvSetTail) R);
		conn-to-min := conclude 
								(= (Prob.probE (Prob.consE Prob.<= (Random.minRVS rvSet) R)) 
			  						 (1.0 - 
		  								(* 
		  									(1.0 - (Random.cdf y R)) 
		  									(RealExt.pow 
		  										(Prob.probE (Prob.consE Prob.> (Random.rvSetIdElmnt rvSetTail) R)) 
		  										(Random.lenRVS rvSetTail)) ))
			  				    )
			  			(!mp PrbMin<= Mi-&-Id)				
	}
	(!chain [ (Prob.probE (Prob.consE Prob.<= (Netwrk.netTd NETWORK) R))
		    = (Prob.probE (Prob.consE Prob.<= (Random.minRVS rvSet) R)) [Td=Min]
			= (1.0 - 
				 (* 
					 (1.0 - (Random.cdf y R)) 
					 (RealExt.pow 
						 (Prob.probE (Prob.consE Prob.> (Random.rvSetIdElmnt rvSetTail) R)) 
						 (Random.lenRVS rvSetTail)) )) [conn-to-min]
		])


}# end module
